---
title: v7 to v8 Migration Guide
description: This is a step by step migration guide to move from JobRunr v7 to JobRunr v8.
weight: 10  
tags:
    - v8
    - Migration
hideFrameworkSelector: true
---

This guide documents how to migrate to JobRunr v8. For feedback on any feature in this release don’t hesitate to reach to developers@jobrunr.io.  We’re looking forward to your feedback! (for technical questions unrelated to this beta, please contact support@jobrunr.io).

> **Important**: This release has a few breaking changes and is not backward compatible due additional fields (e.g., the `createdBy` field in `RecurringJob`).


## Table of contents

<div class="toc">

- [Installation](#installation)
- [Breaking changes](#breaking-changes)
- [Carbon Aware Jobs](#carbon-aware-jobs)
- [Reduced database load](#reduce-database-load)
- [Ahead of time RecurringJob scheduling](#ahead-of-time-recurringjob-scheduling)
- [Kotlin Serialisation support](#kotlin-serialisation-support)
- [@AsyncJob to reduce boilerplate](#asyncjob-to-reduce-boilerplate)
- [@Recurring synchronisation](#-ecurring-synchronisation)
- {{< label version="professional" >}}JobRunr Pro{{< /label >}} [Database row locking strategy configuration](#database-row-locking-strategy-configuration)
- {{< label version="professional" >}}JobRunr Pro{{< /label >}} [Automatic deletion of failed jobs](#automatic-deletion-of-failed-jobs)
- {{< label version="professional" >}}JobRunr Pro{{< /label >}} [Multi-Cluster Dashboard](#multi-cluster-dashboard)
- {{< label version="professional" >}}JobRunr Pro{{< /label >}} [K8s autoscaling](#k8s-autoscaling)
- {{< label version="professional" >}}JobRunr Pro{{< /label >}} [Label order and color on the Dashboard](#label-order-and-color-on-the-dashboard)
- {{< label version="professional" >}}JobRunr Pro{{< /label >}} [Automatic deletion of batch child jobs via the Dashboard](#automatic-deletion-of-batch-child-jobs-via-the-dashboard)
- {{< label version="professional" >}}JobRunr Pro{{< /label >}} [Pause dynamic queues](#pause-dynamic-queues)
- {{< label version="professional" >}}JobRunr Pro{{< /label >}} [Ratelimiting configuration at runtime](#ratelimiting-configuration-at-runtime)
- {{< label version="professional" >}}JobRunr Pro{{< /label >}} [Faster processing with SmartQueue](#faster-processing-with-smartqueue)
- {{< label version="professional" >}}JobRunr Pro{{< /label >}} [Improvement to saveReplace and createOrReplace()](#improvement-to-savereplace-and-createorreplace)
- {{< label version="professional" >}}JobRunr Pro{{< /label >}} [Load license key using properties](#load-license-key-using-properties)

</div>

## Installation

For the OSS version, the v8 release is available in the [Maven Central repository](https://mvnrepository.com/artifact/org.jobrunr/jobrunr).

For Pro customers, the v8 release is available on our private Maven repository. 

Simply replace the version you’re on with `8.0.0-beta.1`.


## Carbon _Aware_ Jobs

From version `beta.2` and on, the v8 release of JobRunr allows to add a margin to the schedule of (reucrring) jobs in order to reduce the carbon footprint of your data centre(s). This is a **brand new feature** and therefore requires no special migration. 

To learn more about the feature, follow the [How To Reduce Your Carbon Impact With Carbon Aware Jobs](/en/guides/intro/how-to-reduce-carbon-impact-with-carbon-aware-jobs/) guide.

♥ Thanks to the folks from [MindWave](https://www.mindwave.com/) for helping us realize this feature!

## Reduced database load

In JobRunr v8, we’ve reviewed the datatypes, queries and indexes to improve performance and reduce the load on the database. In our tests we’ve seen at least 2x improvement across all databases when all JobRunr features (such as dynamic queues, rate limiters, batch jobs, etc.) are enabled. In practice, you can expect less load on your database as queries run faster and data takes less space.

> **BREAKING** : Databases with column type changes: Oracle, MariaDB, MySQL, and SQL Server

## Multi-Cluster Dashboard

The JobRunr Pro Multi-Cluster Dashboard is a separate web server that offers a unified view over multiple JobRunr Pro clusters. Monitoring multiple instances can get tiresome when running a lot of different clusters, all running their own jobs. With the Multi-Cluster Dashboard, you can monitor the health of all clusters in one place. 

For more information on how this works and how to configure it, please see the [JobRunr Pro Documentation](/en/documentation/pro/jobrunr-pro-multi-dashboard/).

Note: the multi cluster dashboard is designed to be deployed as a standalone application and requires JDK 21 or higher.

## K8s autoscaling

JobRunr Pro v8 provides different metrics (e.g., the worker’s usage, the amount of enqueued jobs, etc.),  to customize Kubernetes autoscaling. We’ve written [another guide](/en/guides/advanced/k8s-autoscaling/) to demonstrate the power of these metrics when provided to KEDA 


## Ahead of time RecurringJob scheduling

In v7 and lower, JobRunr schedules recurring jobs very close to the moment they need to run (typically a minute earlier). In v8, JobRunr schedules the recurring job as soon as the previous run is finished.

For example, take a recurring job that runs daily at midnight.

Behaviour in v7:
- JobRunr attempts to schedule the job everyday at ~11:59pm.

Behaviour in v8 (assuming the recurring job is recently created):
- JobRunr schedules an initial run at 12:00 am and attempts to schedule the next for the following day at 12:00 am when the previous run is done.

_Why attempt?_ Because JobRunr prevents concurrent runs of the same recurring job by default.

Limitations:

- in JobRunr Pro, recurring jobs with a scheduling interval lower than a minute still behave as in v7.
- a triggered (directly enqueued) recurring job on the dashboard, won't prevent JobRunr from scheduling new ones

## Kotlin Serialisation support

JobRunr v8 introduces a new `JsonMapper`; the `KotlinxSerializationJsonMapper` to improve the Kotlin developer’s experience when using JobRunr. 

### Usage

Setup the dependencies kotlinx-serialization dependencies as demonstrated in [the official Kotlin documentation](https://kotlinlang.org/docs/serialization.html#add-plugins-and-dependencies). And add JobRunr’s Kotlin language support. JobRunr’s support for Kotlin Serialisation is only available from Kotlin versions 2.1 or higher so we need to add the artifact `jobrunr-pro-kotlin-2.1-support`.

```
plugins {
kotlin("plugin.serialization") version "2.1.20"
}

dependencies {
implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.8.0")
implementation("org.jobrunr:jobrunr-pro-kotlin-2.1-support:8.0.0-beta.1")
}
```

In the beta you’ll need to programmatically configure the `KotlinxSerializationJsonMapper` either using JobRunr fluent API or by replacing the default `JsonMapper` bean provided by JobRunr’s autoconfiguration.

> **Note**: we have not tested versions lower than 1.8.0 of kotlinx-serialization-json. Additionally, `KotlinxSerializationJsonMapper` may not be able to deserialize items serialized by another `JsonMapper`.

Example with the fluent API:

{{< codeblock >}}

```java
@OptIn(InternalSerializationApi::class, ExperimentalSerializationApi::class)
fun main() {
    val scheduler = JobRunrPro.configure()
        .useJsonMapper(KotlinxSerializationJsonMapper())
        .useStorageProvider(InMemoryStorageProvider())
        .useDashboard()
        .useBackgroundJobServer()
        .initialize()
        .jobScheduler!!
}
```
{{</ codeblock >}}

♥ Thanks to [@SIMULATAN](https://github.com/SIMULATAN) for contributing this feature!

## Label order and color on the Dashboard

Since their introduction, JobRunr stored labels in no particular order (technically as a `Set`). From v8 onwards, the labels will be stored in the order defined by the user (technically as a `List`). This gives developers control over the order the labels are going to be displayed on the Dashboard.

With JobRunr Pro v8, you have even greater power over ordering and colors thanks to the introduction of the Dashboard configuration: `LabelConfiguration`.

### Usage

Users can provide a list of `LabelConfiguration`, each defining a `labelPrefix` and optionally a `color` in `rgb` or `hex` format. If the color is omitted, a random color is consistently applied to all labels that match the configured prefix.

Additionally, once a label is configured, it'll be displayed in the order it appears in the configuration. If the following is the configuration:

```
jobrunr:
    ...
    dashboard:
      enabled: true
      label-configuration:
        - label-prefix: tenant
          color: "#333333"
        - label-prefix: building
          color: "#777777"
```

Any label prefixed with `tenant` will appear first in the list of labels of a job when displayed on the dashboard. If prefixed with `building` it'll appear second if a label with tenant is also present (otherwise it'll be displayed first). Any other label not prefixed with a configured label-prefix will appear after the `tenant` and `building` prefixed labels.

## Automatic deletion of batch child jobs via the Dashboard

When deleting a `BatchJob` from the Dashboard, the user is provided with the option of deleting all the child `Job`s of the batch.

Limitation: this option is only available if deleting one `BatchJob` at a time.

## Pause dynamic queues

Dynamic queues can now be paused from the Dashboard or programmatically. 

### Usage

Pausing a dynamic queue from the Dashboard is as simple as going to your configured dynamic queue page and clicking on the spinning wheel. To resume you only have to click again.

Pausing a dynamic queue programmatically requires access to a `DynamicQueueManager` instance (which can be created by providing a `StorageProvider` and a `JsonMapper`). To pause a queue or multiple, call: `pauseDynamicQueueJobProcessing()` with the queues to pause. To resume, call `resumeDynamicQueueJobProcessing()` with the queues to resume.

## Ratelimiting configuration at runtime

## Faster processing with SmartQueue

Would you like even higher processing throughput? Try our new queuing mechanism: the `SmartQueue`. To increase the throughput JobRunr tries to eliminate the latency to get the jobs to process. With this queuing system, a worker no longer needs to go to the database when they finish, it can pick a `Job` from the ones JobRunr fetched right before it finishes.

This feature is particularly useful when processing short running jobs. Using it for long running jobs may also slightly reduce the overall processing time, making it suitable for mixed queues with short and long running jobs.

> **Note**: do not use the SmartQueue if you're using RateLimiters. We still need to improve the SmartQueue to work well with RateLimiters too.

### Usage

You’ll need to provide the SmartQueueBackgroundJobServerWorkerPolicy. Either via the Fluent API:

{{< codeblock >}}
```java
JobRunrPro
.configure()
.useBackgroundJobServer(
    usingStandardBackgroundJobServerConfiguration()
    .andBackgroundJobServerWorkerPolicy(new SmartQueueBackgroundJobServerWorkerPolicy())
);
```
{{</ codeblock >}}

Or via a Spring/Quarkus/Micronaut Bean

{{< codeblock >}}
```java
@Bean
public BackgroundJobServerWorkerPolicy backgroundJobServerWorkerPolicy() {
    JobRunrProperties.BackgroundJobServer backgroundJobServerProperties = properties.getBackgroundJobServer();
    BackgroundJobServerThreadType threadType = ofNullable(backgroundJobServerProperties.getThreadType()).orElse(BackgroundJobServerThreadType.getDefaultThreadType());
    int workerCount = ofNullable(backgroundJobServerProperties.getWorkerCount()).orElse(threadType.getDefaultWorkerCount());
    return new SmartQueueBackgroundJobServerWorkerPolicy(workerCount, threadType);
}
```
{{</ codeblock >}}

The above is an example for Spring Boot, the user should adapt the code to their needs.

The `SmartQueueBackgroundJobServerWorkerPolicy` can be provided with a `BackgroundJobServerThreadType` and a worker count.

**Limitation**: can’t be used together with dynamic queues.

## Improvement to saveReplace and createOrReplace()

This API has seen a few significant improvements:
You can now insert or replace multiple jobs at once via the JobScheduler or JobRequestScheduler API using `createOrReplace(Stream<JobBuilder>)` or the StorageProvider API using `saveReplace(List<Job>)`.

For Postgres, MariaDB, MySQL and SQLite, JobRunr now performs an upsert.

## @AsyncJob to reduce boilerplate

This feature reduces the boilerplate needed to enqueue a Job. A call to a method, annotated with @Job from a class annotated with `@AsyncJob`, will be intercepted by JobRunr. Instead of the method being executed, an enqueued Job will be created and saved for later execution. This works similarly to Spring’s @Async, which executes the method asynchronously. 

Limitation: currently only available for Spring applications.

### Usage

{{< codeblock >}}
```java
@Test
public void testAsyncJob() {
    asyncJobTestService.testMethodAsAsyncJob();
    await().atMost(30, TimeUnit.SECONDS).until(() -> storageProvider.countJobs(StateName.SUCCEEDED) == 1);
}

@AsyncJob
public static class AsyncJobTestService {

    @Job(name = "my async spring job")
    public void testMethodAsAsyncJob() {
        LOGGER.info("Running AsyncJobService.testMethodAsAsyncJob in a job");
    }
}
```
{{</ codeblock >}}

## @Recurring synchronisation

This feature aims to reduce manual intervention by automatically deleting a RecurringJob when JobRunr cannot find the associated method or when the method is no longer annotated with @Recurring.

## Load license key using properties

The license key can now be loaded via the property `jobrunr.license-key`.

## Database row locking strategy configuration

Pre JobRunr v7, JobRunr made use of optimistic locking to guarantee that jobs are not processed concurrently. In v7, we moved to `FOR UPDATE SKIP LOCKED` for the databases that support it.

In v8, it’s possible to configure this behaviour, you can choose not to use `FOR UPDATE SKIP LOCKED` even if your database supports it. You can disable and fallback to optimistic locking with `jobrunr.database.select-for-update-skip-locked-enabled=false` or using `SqlStorageProviderFactory#using(javax.sql.DataSource, java.lang.String, org.jobrunr.storage.DatabaseOptions)`.

## Automatic deletion of failed jobs

By default, failed jobs are never deleted and require user intervention to handle them. This behaviour is reasonable as you almost certainly want to be aware of job failures. JobRunr Pro v8 allows to configure the period after which to automatically delete failed jobs.

### Usage

Via a property: 

```
jobrunr.background-job-server.delete-failed-jobs-after=PT365D
```

Via the fluent API:

{{< codeblock >}}
```java
JobRunrPro.configure()
//...
.useBackgroundJobServer(
usingStandardBackgroundJobServerConfiguration()
.andDeleteFailedJobsAfter(Duration.ofDays(365))
).initialize();
```
{{</ codeblock >}}

## Breaking changes

- The Redis and Elasticsearch StorageProviders were deprected in v7 and are removed from JobRunr in v8.
- `AbstractJob#setLabels`, `JobBuilder#withLabels` and `RecurringJobBuilder#withLabels` now expect a `List` instead of a `Set` as an argument. 
- Micrometer: job stats metrics have changed name. Before: `jobrunr.jobs.[statename]` (where statename takes the value varies.  After: `jobrunr.jobs.by-state`
-  `Set<String> getDistinctDynamicQueues(StateName... stateNames)`; has been removed from the StorageProvider.
- `JobDashboardProgressBar`: method increaseByOne renamed to `incrementSucceeded`
- `JobBuilder`: method `runAfter(...)` is replaced by `runAfterSuccessOf(...)`
- `ScheduledState`: removed constructor `ScheduledState(Instant scheduledAt, RecurringJob recurringJob)`; use `ScheduledState.fromRecurringJob(Instant scheduledAt, RecurringJob recurringJob)` instead.
- `RecurringJob`: constructors signature have changed.
- Removed `StorageProvider#getRecurringJobIdsOfJobsWithState(StateName... states)`; use `StorageProvider#getRecurringJobIdsOfJobs(JobSearchRequest jobSearchRequest)` instead.
- Removed the `org` prefix from JobRunr’s Spring properties
- Exposed transaction package name change: from `org.jobrunr.exposed.transaction.sql` to `org.jobrunr.kotlin.storage.sql.exposed`

